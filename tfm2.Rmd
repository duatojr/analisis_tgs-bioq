Función
```{r}
library(readxl)
library(dplyr)
library(ggplot2)
library(tidyr)
library(skimr)
library(GGally)
library(corrplot)
library(stringr)
library(tidyverse)
library(FactoMineR)
library(factoextra)
library(plotly)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggcorrplot)
library(pROC) # Nueva librería para curvas ROC. Asegúrate de instalarla: install.packages("pROC")
datos <- read_excel("/Users/jorge/Desktop/Estudios/UFV/TFM/TFM/datos_sporting_completos.xlsx")
print(datos)
analizar_bio_tgs_jugador <- function(datos,
                                     columna_sujeto_id,
                                     tgs_variable_nombre,
                                     bioquimica_base_nombre) {

  # --- 1. Validación de Entradas y Preparación de Nombres de Columnas ---
  if (!is.data.frame(datos)) {
    stop("El primer argumento 'datos' debe ser un data frame.")
  }
  if (!is.character(columna_sujeto_id) || length(columna_sujeto_id) != 1 || !(columna_sujeto_id %in% colnames(datos))) {
    stop(paste0("El argumento 'columna_sujeto_id' ('", columna_sujeto_id, "') debe ser un nombre de columna válido en 'datos'."))
  }
  datos[[columna_sujeto_id]] <- as.factor(datos[[columna_sujeto_id]])

  if (!is.character(tgs_variable_nombre) || length(tgs_variable_nombre) != 1 || !(tgs_variable_nombre %in% colnames(datos))) {
    stop(paste0("'tgs_variable_nombre' ('", tgs_variable_nombre, "') debe ser un nombre de columna válido en 'datos'."))
  }
  if (!is.numeric(datos[[tgs_variable_nombre]])) {
      warning(paste0("La columna TGS '", tgs_variable_nombre, "' no es numérica. Se intentará usar para colorear, pero una escala continua podría no ser apropiada."))
  }

  if (!is.character(bioquimica_base_nombre) || length(bioquimica_base_nombre) != 1) {
    stop("'bioquimica_base_nombre' debe ser una cadena de texto con el nombre base de la variable bioquímica.")
  }

  nombres_bio_tomas <- paste0(bioquimica_base_nombre, 1:6, "º")
  for (col_bio in nombres_bio_tomas) {
    if (!(col_bio %in% colnames(datos))) {
      stop(paste0("La columna bioquímica '", col_bio, "' no se encuentra en el data frame."))
    }
    if (!is.numeric(datos[[col_bio]])) {
      stop(paste0("La columna bioquímica '", col_bio, "' debe ser numérica para el análisis."))
    }
  }

  # --- SECCIÓN MANTENIDA: Correlaciones y Matriz (como en la función anterior) ---
  resultados_individuales_lista <- list()
  for (i in 1:6) {
    col_bio_actual <- nombres_bio_tomas[i]
    test_resultado <- tryCatch({
      cor.test(datos[[tgs_variable_nombre]], datos[[col_bio_actual]],
               method = "pearson", use = "pairwise.complete.obs")
    }, error = function(e) {
      warning(paste("No se pudo calcular la correlación entre", tgs_variable_nombre, "y", col_bio_actual, ":", e$message))
      return(list(estimate = NA, p.value = NA))
    })
    resultados_individuales_lista[[i]] <- data.frame(
      Variable_TGS = tgs_variable_nombre,
      Variable_Bioquimica_Toma = col_bio_actual,
      Toma = i,
      Coeficiente_Correlacion = ifelse(is.null(test_resultado$estimate), NA, test_resultado$estimate[[1]]),
      P_Valor = ifelse(is.null(test_resultado$p.value), NA, test_resultado$p.value)
    )
  }
  tabla_correlaciones_individuales <- do.call(rbind, resultados_individuales_lista)

  columnas_para_matriz <- c(tgs_variable_nombre, nombres_bio_tomas)
  datos_subset_matriz <- datos[, columnas_para_matriz, drop = FALSE]
  datos_subset_matriz_completos <- datos_subset_matriz[rowSums(is.na(datos_subset_matriz)) < ncol(datos_subset_matriz), ]

  matriz_cor <- NA
  plot_matriz_cor <- NULL
  if(nrow(datos_subset_matriz_completos) >= 2 && ncol(datos_subset_matriz_completos) > 0 && all(sapply(datos_subset_matriz_completos, is.numeric))) {
      matriz_cor <- cor(datos_subset_matriz_completos, use = "pairwise.complete.obs")
      if(requireNamespace("ggcorrplot", quietly = TRUE)) {
           plot_matriz_cor <- ggcorrplot::ggcorrplot(matriz_cor, hc.order = TRUE, type = "lower", lab = TRUE, lab_size = 3,
                                           colors = c("#6D9EC1", "white", "#E46726"),
                                           title = paste("Matriz de Correlación:\n", tgs_variable_nombre, "&", bioquimica_base_nombre)) +
             theme(plot.title = element_text(hjust = 0.5))
      } else {
          warning("Paquete 'ggcorrplot' no instalado. La matriz de correlación no será graficada, solo devuelta como tabla.")
      }
  } else {
      warning("No hay suficientes datos numéricos completos para calcular o graficar la matriz de correlación.")
  }

  # --- NUEVO: Preparación de Datos para Gráfico de Trayectorias y Outliers ---
  columnas_seleccionadas_plot <- c(columna_sujeto_id, tgs_variable_nombre, nombres_bio_tomas)
  datos_plot_largo <- datos %>%
    select(all_of(columnas_seleccionadas_plot)) %>%
    pivot_longer(
      cols = all_of(nombres_bio_tomas),
      names_to = "Toma_Nombre",
      values_to = "Valor_Bioquimico"
    ) %>%
    mutate(Toma = as.integer(gsub(paste0("^", bioquimica_base_nombre, "(\\d)º$"), "\\1", Toma_Nombre))) %>%
    filter(!is.na(Toma))

  if(nrow(datos_plot_largo) == 0){
      stop("No se pudieron generar datos en formato largo para el gráfico de trayectorias. Verifique los nombres de las columnas bioquímicas.")
  }

  # --- MODIFICACIÓN: Gráfico de Trayectorias Individuales con línea de tendencia ---
  grafico_trayectorias_individuales <- ggplot(datos_plot_largo,
                                             aes(x = Toma,
                                                 y = Valor_Bioquimico,
                                                 group = .data[[columna_sujeto_id]],
                                                 color = .data[[tgs_variable_nombre]])) +
    geom_line(alpha = 0.7) +
    geom_point(alpha = 0.7, size = 1.5) +
    # Añadir la línea de tendencia (media) en rojo
    stat_summary(aes(group = 1), fun = mean, geom = "line", color = "red", size = 1.2, linetype = "dashed") +
    stat_summary(aes(group = 1), fun = mean, geom = "point", color = "red", size = 2, shape = 18) + # Puntos para la media
    scale_x_continuous(breaks = 1:6) +
    labs(
      title = paste("Trayectorias de", bioquimica_base_nombre, "por Sujeto"),
      subtitle = paste("Coloreado por", tgs_variable_nombre, "\nLínea de tendencia roja: Media"),
      x = "Toma (Tiempo)",
      y = paste("Valor de", bioquimica_base_nombre),
      color = tgs_variable_nombre
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          plot.subtitle = element_text(hjust = 0.5),
          legend.position = "bottom")

  if (!is.numeric(datos_plot_largo[[tgs_variable_nombre]])) {
    grafico_trayectorias_individuales <- grafico_trayectorias_individuales +
      scale_color_brewer(palette = "Set1")
  } else {
    grafico_trayectorias_individuales <- grafico_trayectorias_individuales +
      scale_color_viridis_c()
  }

  # --- NUEVO: Detección de Outliers ---
  tabla_outliers <- datos_plot_largo %>%
    group_by(Toma) %>%
    mutate(
      Q1 = quantile(Valor_Bioquimico, 0.25, na.rm = TRUE),
      Q3 = quantile(Valor_Bioquimico, 0.75, na.rm = TRUE),
      IQR_val = Q3 - Q1,
      Limite_Inferior = Q1 - 1.5 * IQR_val,
      Limite_Superior = Q3 + 1.5 * IQR_val,
      Es_Outlier = Valor_Bioquimico < Limite_Inferior | Valor_Bioquimico > Limite_Superior,
      Tipo_Outlier = case_when(
        Valor_Bioquimico < Limite_Inferior ~ "Bajo",
        Valor_Bioquimico > Limite_Superior ~ "Alto",
        TRUE ~ "Normal"
      )
    ) %>%
    filter(Es_Outlier) %>%
    select(all_of(columna_sujeto_id), Toma, Toma_Nombre, Valor_Bioquimico, Tipo_Outlier, Limite_Inferior, Limite_Superior) %>%
    arrange(Toma, .data[[columna_sujeto_id]])

  # --- NUEVO: Generación de Curvas ROC para correlaciones significativas ---
  lista_curvas_roc <- list()
  for (i in 1:nrow(tabla_correlaciones_individuales)) {
    corr_row <- tabla_correlaciones_individuales[i, ]
    p_valor <- corr_row$P_Valor
    col_bio_actual <- corr_row$Variable_Bioquimica_Toma

    # Verificar si el p-valor es significativo y si hay suficientes datos
    if (!is.na(p_valor) && p_valor < 0.05 &&
        !is.null(datos[[tgs_variable_nombre]]) && !is.null(datos[[col_bio_actual]]) &&
        sum(!is.na(datos[[tgs_variable_nombre]]) & !is.na(datos[[col_bio_actual]])) > 1) {

      # Para la curva ROC, necesitamos un "estado verdadero" binario (ej. "enfermo" vs "sano")
      # y una "puntuación" continua. Dado que TGS% es continuo,
      # asumiremos un umbral (ej. la media o mediana de TGS%) para crear una variable binaria.
      # ¡IMPORTANTE!: Ajusta este umbral y la lógica binaria según tu definición de "positivo" en TGS.
      # Por ejemplo, si un TGS% alto indica un problema.
      # Aquí, un ejemplo: "TGS_Alto" si %TGS es mayor que la mediana global.
      tgs_binario <- as.factor(datos[[tgs_variable_nombre]] > median(datos[[tgs_variable_nombre]], na.rm = TRUE))

      # Asegurarse de que la variable binaria tenga al menos dos niveles
      if (nlevels(tgs_binario) < 2) {
        warning(paste("No se puede generar curva ROC para", col_bio_actual,
                      "porque la variable TGS binaria solo tiene un nivel. Ajuste el umbral de TGS%."))
        next
      }

      # Crear un dataframe limpio para ROC
      roc_data <- data.frame(
        response = tgs_binario,
        predictor = datos[[col_bio_actual]]
      )
      roc_data <- na.omit(roc_data) # Eliminar NAs para ROC

      if (nrow(roc_data) > 1 && nlevels(roc_data$response) == 2) { # Asegurar que hay suficientes datos y 2 clases
        tryCatch({
          roc_obj <- roc(response = roc_data$response,
                         predictor = roc_data$predictor,
                         levels = rev(levels(roc_data$response))) # Asegura que el "positivo" es el segundo nivel
          
          # Crear el gráfico ROC
          plot_roc <- ggroc(roc_obj) +
            geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "darkgrey", linetype = "dashed") +
            labs(title = paste("Curva ROC para", col_bio_actual, "prediciendo", tgs_variable_nombre,
                               "\n(AU ROC:", round(auc(roc_obj), 2), ")"),
                 x = "False Positive Rate",
                 y = "True Positive Rate") +
            theme_minimal() +
            theme(plot.title = element_text(hjust = 0.5, face = "bold"))

          lista_curvas_roc[[col_bio_actual]] <- plot_roc

        }, error = function(e) {
          warning(paste("Error al generar la curva ROC para", col_bio_actual, ":", e$message))
        })
      } else {
         warning(paste("No hay suficientes datos para generar curva ROC para", col_bio_actual,
                       "o la variable binaria no tiene dos niveles después de NA o umbral."))
      }
    }
  }

  # --- Devolver Resultados ---
  return(list(
    tabla_correlaciones_individuales = tabla_correlaciones_individuales,
    matriz_correlacion_completa = matriz_cor,
    plot_matriz_correlacion = plot_matriz_cor,
    grafico_trayectorias_individuales = grafico_trayectorias_individuales,
    tabla_outliers = tabla_outliers,
    curvas_roc_significativas = lista_curvas_roc # NUEVO: Lista de gráficos ROC
  ))
}
```


EJECUTAR FUNCIÓN CORRELACIÓN TGS MUSCULAR Y VARIABELS
```{r}
# Variable TGS fija
tgs_fija <- "%TGS muscular"

# Lista de nombres base de las variables bioquímicas a analizar
variables_bioquimicas_a_iterar <- c("FERRIT", "FE", "CPK", "LDH", "CREATIN")

# Bucle con lapply
# Esta lista almacenará todos los resultados, cada elemento será el resultado de un análisis
todos_los_analisis <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {
  
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))
  
  # Usamos tryCatch para que si una variable da error, el bucle continúe con las demás
  resultado_para_esta_bio <- tryCatch({
    analizar_bio_tgs_jugador(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si ocurre un error, lo notificamos y devolvemos un mensaje de error o NULL
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio)) # Devolvemos el error
  })
  
  return(resultado_para_esta_bio)
})

# --- PASO 3: Nombrar los elementos de la lista de resultados ---
# Esto hace más fácil acceder a los resultados de una variable bioquímica específica por su nombre.
names(todos_los_analisis) <- variables_bioquimicas_a_iterar
```

Resultados Ferritina
```{r}
todos_los_analisis$FERRIT
```

Resultados Fe
```{r}
todos_los_analisis$FE
```


Resultados CPK
```{r}
todos_los_analisis$CPK
```

Resultados LDH
```{r}
todos_los_analisis$LDH
```

Resultados Creatina
```{r}
todos_los_analisis$CREATIN
```

EJECUTAR FUNCIÓN CORRELACIÓN TGS HEPÁTICO Y VARIABELS
```{r}
# Variable TGS fija
tgs_fija <- "%TGS hepático"

# Lista de nombres base de las variables bioquímicas a analizar
variables_bioquimicas_a_iterar <- c("GOT", "GPT", "GGT", "UREA", "BUN")

# Bucle con lapply
# Esta lista almacenará todos los resultados, cada elemento será el resultado de un análisis
todos_los_analisis2 <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {
  
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))
  
  # Usamos tryCatch para que si una variable da error, el bucle continúe con las demás
  resultado_para_esta_bio <- tryCatch({
    analizar_bio_tgs_jugador(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si ocurre un error, lo notificamos y devolvemos un mensaje de error o NULL
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio)) # Devolvemos el error
  })
  
  return(resultado_para_esta_bio)
})

# --- PASO 3: Nombrar los elementos de la lista de resultados ---
# Esto hace más fácil acceder a los resultados de una variable bioquímica específica por su nombre.
names(todos_los_analisis2) <- variables_bioquimicas_a_iterar
```

Resultados GOT
```{r}
todos_los_analisis2$GOT
```

Resultados GPT
```{r}
todos_los_analisis2$GPT
```

Resultados GGT
```{r}
todos_los_analisis2$GGT
```

Resultados UREA
```{r}
todos_los_analisis2$UREA
```

Resultados BUN
```{r}
todos_los_analisis2$BUN
```

EJECUTAR FUNCIÓN CORRELACIÓN TGS CARDIO Y VARIABELS
```{r}
# Variable TGS fija
tgs_fija <- "%TGS cardio"

# Lista de nombres base de las variables bioquímicas a analizar
variables_bioquimicas_a_iterar <- c("CPK")

# Bucle con lapply
# Esta lista almacenará todos los resultados, cada elemento será el resultado de un análisis
todos_los_analisis2 <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {
  
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))
  
  # Usamos tryCatch para que si una variable da error, el bucle continúe con las demás
  resultado_para_esta_bio <- tryCatch({
    analizar_bio_tgs_jugador(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si ocurre un error, lo notificamos y devolvemos un mensaje de error o NULL
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio)) # Devolvemos el error
  })
  
  return(resultado_para_esta_bio)
})

# --- PASO 3: Nombrar los elementos de la lista de resultados ---
# Esto hace más fácil acceder a los resultados de una variable bioquímica específica por su nombre.
names(todos_los_analisis2) <- variables_bioquimicas_a_iterar
```

Resultados CPK
```{r}
todos_los_analisis2$CPK
```

EJECUTAR FUNCIÓN CORRELACIÓN TGS EFICACIA Y VARIABELS
```{r}
# Variable TGS fija
tgs_fija <- "%TGS eficacia"

# Lista de nombres base de las variables bioquímicas a analizar
variables_bioquimicas_a_iterar <- c("GOT", "GPT", "GGT", "CPK", "FE", "FERRIT", "HMTCO", "HB", "HEMAT")

# Bucle con lapply
# Esta lista almacenará todos los resultados, cada elemento será el resultado de un análisis
todos_los_analisis2 <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {
  
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))
  
  # Usamos tryCatch para que si una variable da error, el bucle continúe con las demás
  resultado_para_esta_bio <- tryCatch({
    analizar_bio_tgs_jugador(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si ocurre un error, lo notificamos y devolvemos un mensaje de error o NULL
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio)) # Devolvemos el error
  })
  
  return(resultado_para_esta_bio)
})

# --- PASO 3: Nombrar los elementos de la lista de resultados ---
# Esto hace más fácil acceder a los resultados de una variable bioquímica específica por su nombre.
names(todos_los_analisis2) <- variables_bioquimicas_a_iterar
```

Resultados GOT
```{r}
todos_los_analisis2$GOT
```

Resultados GPT
```{r}
todos_los_analisis2$GPT
```

Resultados GGT
```{r}
todos_los_analisis2$GGT
```

Resultados CPK
```{r}
todos_los_analisis2$CPK
```

Resultados FE
```{r}
todos_los_analisis2$FE
```

Resultados FERRITINA
```{r}
todos_los_analisis2$FERRIT
```

Resultados HMTCO
```{r}
todos_los_analisis2$HMTCO
```

Resultados HB
```{r}
todos_los_analisis2$HB
```

Resultados HEMAT
```{r}
todos_los_analisis2$HEMAT
```