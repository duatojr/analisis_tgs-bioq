"0","analizar_bio_tgs_jugador <- function(datos,"
"0","                                     columna_sujeto_id,"
"0","                                     tgs_variable_nombre,"
"0","                                     bioquimica_base_nombre) {"
"0",""
"0","  # --- 1. Validación de Entradas y Preparación de Nombres de Columnas ---"
"0","  if (!is.data.frame(datos)) {"
"0","    stop(""El primer argumento 'datos' debe ser un data frame."")"
"0","  }"
"0","  if (!is.character(columna_sujeto_id) || length(columna_sujeto_id) != 1 || !(columna_sujeto_id %in% colnames(datos))) {"
"0","    stop(paste0(""El argumento 'columna_sujeto_id' ('"", columna_sujeto_id, ""') debe ser un nombre de columna válido en 'datos'.""))"
"0","  }"
"0","  datos[[columna_sujeto_id]] <- as.factor(datos[[columna_sujeto_id]])"
"0",""
"0","  if (!is.character(tgs_variable_nombre) || length(tgs_variable_nombre) != 1 || !(tgs_variable_nombre %in% colnames(datos))) {"
"0","    stop(paste0(""'tgs_variable_nombre' ('"", tgs_variable_nombre, ""') debe ser un nombre de columna válido en 'datos'.""))"
"0","  }"
"0","  if (!is.numeric(datos[[tgs_variable_nombre]])) {"
"0","      warning(paste0(""La columna TGS '"", tgs_variable_nombre, ""' no es numérica. Se intentará usar para colorear, pero una escala continua podría no ser apropiada.""))"
"0","  }"
"0",""
"0","  if (!is.character(bioquimica_base_nombre) || length(bioquimica_base_nombre) != 1) {"
"0","    stop(""'bioquimica_base_nombre' debe ser una cadena de texto con el nombre base de la variable bioquímica."")"
"0","  }"
"0",""
"0","  nombres_bio_tomas <- paste0(bioquimica_base_nombre, 1:6, ""º"")"
"0","  for (col_bio in nombres_bio_tomas) {"
"0","    if (!(col_bio %in% colnames(datos))) {"
"0","      stop(paste0(""La columna bioquímica '"", col_bio, ""' no se encuentra en el data frame.""))"
"0","    }"
"0","    if (!is.numeric(datos[[col_bio]])) {"
"0","      stop(paste0(""La columna bioquímica '"", col_bio, ""' debe ser numérica para el análisis.""))"
"0","    }"
"0","  }"
"0",""
"0","  # --- SECCIÓN MANTENIDA: Correlaciones y Matriz (como en la función anterior) ---"
"0","  resultados_individuales_lista <- list()"
"0","  for (i in 1:6) {"
"0","    col_bio_actual <- nombres_bio_tomas[i]"
"0","    test_resultado <- tryCatch({"
"0","      cor.test(datos[[tgs_variable_nombre]], datos[[col_bio_actual]],"
"0","               method = ""pearson"", use = ""pairwise.complete.obs"")"
"0","    }, error = function(e) {"
"0","      warning(paste(""No se pudo calcular la correlación entre"", tgs_variable_nombre, ""y"", col_bio_actual, "":"", e$message))"
"0","      return(list(estimate = NA, p.value = NA))"
"0","    })"
"0","    resultados_individuales_lista[[i]] <- data.frame("
"0","      Variable_TGS = tgs_variable_nombre,"
"0","      Variable_Bioquimica_Toma = col_bio_actual,"
"0","      Toma = i,"
"0","      Coeficiente_Correlacion = ifelse(is.null(test_resultado$estimate), NA, test_resultado$estimate[[1]]),"
"0","      P_Valor = ifelse(is.null(test_resultado$p.value), NA, test_resultado$p.value)"
"0","    )"
"0","  }"
"0","  tabla_correlaciones_individuales <- do.call(rbind, resultados_individuales_lista)"
"0",""
"0","  columnas_para_matriz <- c(tgs_variable_nombre, nombres_bio_tomas)"
"0","  datos_subset_matriz <- datos[, columnas_para_matriz, drop = FALSE]"
"0","  datos_subset_matriz_completos <- datos_subset_matriz[rowSums(is.na(datos_subset_matriz)) < ncol(datos_subset_matriz), ]"
"0",""
"0","  matriz_cor <- NA"
"0","  plot_matriz_cor <- NULL"
"0","  if(nrow(datos_subset_matriz_completos) >= 2 && ncol(datos_subset_matriz_completos) > 0 && all(sapply(datos_subset_matriz_completos, is.numeric))) {"
"0","      matriz_cor <- cor(datos_subset_matriz_completos, use = ""pairwise.complete.obs"")"
"0","      if(requireNamespace(""ggcorrplot"", quietly = TRUE)) {"
"0","           plot_matriz_cor <- ggcorrplot::ggcorrplot(matriz_cor, hc.order = TRUE, type = ""lower"", lab = TRUE, lab_size = 3,"
"0","                                           colors = c(""#6D9EC1"", ""white"", ""#E46726""),"
"0","                                           title = paste(""Matriz de Correlación:\n"", tgs_variable_nombre, ""&"", bioquimica_base_nombre)) +"
"0","             theme(plot.title = element_text(hjust = 0.5))"
"0","      } else {"
"0","          warning(""Paquete 'ggcorrplot' no instalado. La matriz de correlación no será graficada, solo devuelta como tabla."")"
"0","      }"
"0","  } else {"
"0","      warning(""No hay suficientes datos numéricos completos para calcular o graficar la matriz de correlación."")"
"0","  }"
"0",""
"0","  # --- NUEVO: Preparación de Datos para Gráfico de Trayectorias y Outliers ---"
"0","  columnas_seleccionadas_plot <- c(columna_sujeto_id, tgs_variable_nombre, nombres_bio_tomas)"
"0","  datos_plot_largo <- datos %>%"
"0","    select(all_of(columnas_seleccionadas_plot)) %>%"
"0","    pivot_longer("
"0","      cols = all_of(nombres_bio_tomas),"
"0","      names_to = ""Toma_Nombre"","
"0","      values_to = ""Valor_Bioquimico"""
"0","    ) %>%"
"0","    mutate(Toma = as.integer(gsub(paste0(""^"", bioquimica_base_nombre, ""(\\d)º$""), ""\\1"", Toma_Nombre))) %>%"
"0","    filter(!is.na(Toma))"
"0",""
"0","  if(nrow(datos_plot_largo) == 0){"
"0","      stop(""No se pudieron generar datos en formato largo para el gráfico de trayectorias. Verifique los nombres de las columnas bioquímicas."")"
"0","  }"
"0",""
"0","  # --- MODIFICACIÓN: Gráfico de Trayectorias Individuales con línea de tendencia ---"
"0","  grafico_trayectorias_individuales <- ggplot(datos_plot_largo,"
"0","                                             aes(x = Toma,"
"0","                                                 y = Valor_Bioquimico,"
"0","                                                 group = .data[[columna_sujeto_id]],"
"0","                                                 color = .data[[tgs_variable_nombre]])) +"
"0","    geom_line(alpha = 0.7) +"
"0","    geom_point(alpha = 0.7, size = 1.5) +"
"0","    # Añadir la línea de tendencia (media) en rojo"
"0","    stat_summary(aes(group = 1), fun = mean, geom = ""line"", color = ""red"", size = 1.2, linetype = ""dashed"") +"
"0","    stat_summary(aes(group = 1), fun = mean, geom = ""point"", color = ""red"", size = 2, shape = 18) + # Puntos para la media"
"0","    scale_x_continuous(breaks = 1:6) +"
"0","    labs("
"0","      title = paste(""Trayectorias de"", bioquimica_base_nombre, ""por Sujeto""),"
"0","      subtitle = paste(""Coloreado por"", tgs_variable_nombre, ""\nLínea de tendencia roja: Media""),"
"0","      x = ""Toma (Tiempo)"","
"0","      y = paste(""Valor de"", bioquimica_base_nombre),"
"0","      color = tgs_variable_nombre"
"0","    ) +"
"0","    theme_minimal() +"
"0","    theme(plot.title = element_text(hjust = 0.5, face = ""bold""),"
"0","          plot.subtitle = element_text(hjust = 0.5),"
"0","          legend.position = ""bottom"")"
"0",""
"0","  if (!is.numeric(datos_plot_largo[[tgs_variable_nombre]])) {"
"0","    grafico_trayectorias_individuales <- grafico_trayectorias_individuales +"
"0","      scale_color_brewer(palette = ""Set1"")"
"0","  } else {"
"0","    grafico_trayectorias_individuales <- grafico_trayectorias_individuales +"
"0","      scale_color_viridis_c()"
"0","  }"
"0",""
"0","  # --- NUEVO: Detección de Outliers ---"
"0","  tabla_outliers <- datos_plot_largo %>%"
"0","    group_by(Toma) %>%"
"0","    mutate("
"0","      Q1 = quantile(Valor_Bioquimico, 0.25, na.rm = TRUE),"
"0","      Q3 = quantile(Valor_Bioquimico, 0.75, na.rm = TRUE),"
"0","      IQR_val = Q3 - Q1,"
"0","      Limite_Inferior = Q1 - 1.5 * IQR_val,"
"0","      Limite_Superior = Q3 + 1.5 * IQR_val,"
"0","      Es_Outlier = Valor_Bioquimico < Limite_Inferior | Valor_Bioquimico > Limite_Superior,"
"0","      Tipo_Outlier = case_when("
"0","        Valor_Bioquimico < Limite_Inferior ~ ""Bajo"","
"0","        Valor_Bioquimico > Limite_Superior ~ ""Alto"","
"0","        TRUE ~ ""Normal"""
"0","      )"
"0","    ) %>%"
"0","    filter(Es_Outlier) %>%"
"0","    select(all_of(columna_sujeto_id), Toma, Toma_Nombre, Valor_Bioquimico, Tipo_Outlier, Limite_Inferior, Limite_Superior) %>%"
"0","    arrange(Toma, .data[[columna_sujeto_id]])"
"0",""
"0","  # --- NUEVO: Generación de Curvas ROC para correlaciones significativas ---"
"0","  lista_curvas_roc <- list()"
"0","  for (i in 1:nrow(tabla_correlaciones_individuales)) {"
"0","    corr_row <- tabla_correlaciones_individuales[i, ]"
"0","    p_valor <- corr_row$P_Valor"
"0","    col_bio_actual <- corr_row$Variable_Bioquimica_Toma"
"0",""
"0","    # Verificar si el p-valor es significativo y si hay suficientes datos"
"0","    if (!is.na(p_valor) && p_valor < 0.05 &&"
"0","        !is.null(datos[[tgs_variable_nombre]]) && !is.null(datos[[col_bio_actual]]) &&"
"0","        sum(!is.na(datos[[tgs_variable_nombre]]) & !is.na(datos[[col_bio_actual]])) > 1) {"
"0",""
"0","      # Para la curva ROC, necesitamos un ""estado verdadero"" binario (ej. ""enfermo"" vs ""sano"")"
"0","      # y una ""puntuación"" continua. Dado que TGS% es continuo,"
"0","      # asumiremos un umbral (ej. la media o mediana de TGS%) para crear una variable binaria."
"0","      # ¡IMPORTANTE!: Ajusta este umbral y la lógica binaria según tu definición de ""positivo"" en TGS."
"0","      # Por ejemplo, si un TGS% alto indica un problema."
"0","      # Aquí, un ejemplo: ""TGS_Alto"" si %TGS es mayor que la mediana global."
"0","      tgs_binario <- as.factor(datos[[tgs_variable_nombre]] > median(datos[[tgs_variable_nombre]], na.rm = TRUE))"
"0",""
"0","      # Asegurarse de que la variable binaria tenga al menos dos niveles"
"0","      if (nlevels(tgs_binario) < 2) {"
"0","        warning(paste(""No se puede generar curva ROC para"", col_bio_actual,"
"0","                      ""porque la variable TGS binaria solo tiene un nivel. Ajuste el umbral de TGS%.""))"
"0","        next"
"0","      }"
"0",""
"0","      # Crear un dataframe limpio para ROC"
"0","      roc_data <- data.frame("
"0","        response = tgs_binario,"
"0","        predictor = datos[[col_bio_actual]]"
"0","      )"
"0","      roc_data <- na.omit(roc_data) # Eliminar NAs para ROC"
"0",""
"0","      if (nrow(roc_data) > 1 && nlevels(roc_data$response) == 2) { # Asegurar que hay suficientes datos y 2 clases"
"0","        tryCatch({"
"0","          roc_obj <- roc(response = roc_data$response,"
"0","                         predictor = roc_data$predictor,"
"0","                         levels = rev(levels(roc_data$response))) # Asegura que el ""positivo"" es el segundo nivel"
"0","          "
"0","          # Crear el gráfico ROC"
"0","          plot_roc <- ggroc(roc_obj) +"
"0","            geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = ""darkgrey"", linetype = ""dashed"") +"
"0","            labs(title = paste(""Curva ROC para"", col_bio_actual, ""prediciendo"", tgs_variable_nombre,"
"0","                               ""\n(AU ROC:"", round(auc(roc_obj), 2), "")""),"
"0","                 x = ""False Positive Rate"","
"0","                 y = ""True Positive Rate"") +"
"0","            theme_minimal() +"
"0","            theme(plot.title = element_text(hjust = 0.5, face = ""bold""))"
"0",""
"0","          lista_curvas_roc[[col_bio_actual]] <- plot_roc"
"0",""
"0","        }, error = function(e) {"
"0","          warning(paste(""Error al generar la curva ROC para"", col_bio_actual, "":"", e$message))"
"0","        })"
"0","      } else {"
"0","         warning(paste(""No hay suficientes datos para generar curva ROC para"", col_bio_actual,"
"0","                       ""o la variable binaria no tiene dos niveles después de NA o umbral.""))"
"0","      }"
"0","    }"
"0","  }"
"0",""
"0","  # --- Devolver Resultados ---"
"0","  return(list("
"0","    tabla_correlaciones_individuales = tabla_correlaciones_individuales,"
"0","    matriz_correlacion_completa = matriz_cor,"
"0","    plot_matriz_correlacion = plot_matriz_cor,"
"0","    grafico_trayectorias_individuales = grafico_trayectorias_individuales,"
"0","    tabla_outliers = tabla_outliers,"
"0","    curvas_roc_significativas = lista_curvas_roc # NUEVO: Lista de gráficos ROC"
"0","  ))"
"0","}"
