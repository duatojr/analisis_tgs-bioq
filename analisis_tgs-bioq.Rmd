Función
```{r}
# ------------------------------ CARGA DE LIBRERÍAS NECESARIAS ------------------------------
library(readxl)      # Para leer archivos Excel.
library(dplyr)       # Para manipulación de datos.
library(ggplot2)     # Para la creación de gráficos.
library(tidyr)       # Para transformar datos.
library(skimr)       # Para resúmenes de datos (exploración).
library(GGally)      # Para matríces de gráficos (exploración).
library(corrplot)    # Para visualizar matrices de correlación.
library(stringr)     # Para manipulación de cadenas.
library(tidyverse)   # Meta-paquete útil.
library(FactoMineR)
library(factoextra)
library(plotly)
library(ggcorrplot)
library(pROC)
library(car)         # Para test de Levene

# ------------------------------ LECTURA DE DATOS DESDE EXCEL -----------------------------
datos <- read_excel("/Users/jorge/Desktop/Articulo/datos_sporting_completos.xlsx")
print(datos)

# ------------------------------ DEFINICIÓN DE FUNCION PRINCIPAL ---------------------------
analizar_bio_tgs_sin_outliers <- function(datos,
                                     columna_sujeto_id,
                                     tgs_variable_nombre,
                                     bioquimica_base_nombre) {

  # ----------- VALIDACIÓN DE ARGUMENTOS DE ENTRADA -----------
  if (!is.data.frame(datos)) stop("El primer argumento 'datos' debe ser un data frame.")
  if (!is.character(columna_sujeto_id) || length(columna_sujeto_id) != 1 || !(columna_sujeto_id %in% colnames(datos)))
    stop(paste0("El argumento 'columna_sujeto_id' ('", columna_sujeto_id, "') debe ser un nombre de columna válido en 'datos'."))
  datos[[columna_sujeto_id]] <- as.factor(datos[[columna_sujeto_id]])

  if (!is.character(tgs_variable_nombre) || length(tgs_variable_nombre) != 1 || !(tgs_variable_nombre %in% colnames(datos)))
    stop(paste0("'tgs_variable_nombre' ('", tgs_variable_nombre, "') debe ser un nombre de columna válido en 'datos'."))
  if (!is.numeric(datos[[tgs_variable_nombre]]))
    warning(paste0("La columna TGS '", tgs_variable_nombre, "' no es numérica."))

  if (!is.character(bioquimica_base_nombre) || length(bioquimica_base_nombre) != 1)
    stop("'bioquimica_base_nombre' debe ser una cadena de texto.")

  # ----------- COMPROBACIÓN DE COLUMNAS BIOQUÍMICAS ESPERADAS -----------
  nombres_bio_tomas <- paste0(bioquimica_base_nombre, 1:6, "º")
  for (col_bio in nombres_bio_tomas) {
    if (!(col_bio %in% colnames(datos)))
      stop(paste0("La columna bioquímica '", col_bio, "' no se encuentra en el data frame."))
    if (!is.numeric(datos[[col_bio]]))
      stop(paste0("La columna bioquímica '", col_bio, "' debe ser numérica."))
  }

  # ------------------ ANÁLISIS DE NORMALIDAD PARA CADA TOMA -----------------
  normalidad_tests <- lapply(nombres_bio_tomas, function(col_bio_actual) {
    datos_bio <- datos[[col_bio_actual]]
    datos_bio <- datos_bio[!is.na(datos_bio)]
    if(length(datos_bio) >= 3) {
      shapiro_result <- shapiro.test(datos_bio)
      return(data.frame(
        Variable = col_bio_actual,
        W = as.numeric(shapiro_result$statistic),
        p_value = shapiro_result$p.value
      ))
    } else {
      return(data.frame(
        Variable = col_bio_actual,
        W = NA,
        p_value = NA
      ))
    }
  })
  tabla_normalidad <- do.call(rbind, normalidad_tests)

  # ------------------ ANÁLISIS DE HOMOCEDASTICIDAD (Levene) -----------------
  tabla_homocedasticidad <- data.frame(
    Variable = character(),
    F_value = numeric(),
    p_value = numeric(),
    stringsAsFactors = FALSE
  )
  tgs_binarizada <- as.factor(datos[[tgs_variable_nombre]] > median(datos[[tgs_variable_nombre]], na.rm = TRUE))
  for (col_bio_actual in nombres_bio_tomas) {
    datos_lev <- data.frame(
      grupo = tgs_binarizada,
      value = datos[[col_bio_actual]]
    )
    datos_lev <- na.omit(datos_lev)
    if (nrow(datos_lev) >= 6 && length(unique(datos_lev$grupo)) == 2) {
      levene_result <- leveneTest(value ~ grupo, data = datos_lev)
      tabla_homocedasticidad <- rbind(
        tabla_homocedasticidad,
        data.frame(
          Variable = col_bio_actual,
          F_value = levene_result$"F value"[1],
          p_value = levene_result$"Pr(>F)"[1]
        )
      )
    } else {
      tabla_homocedasticidad <- rbind(tabla_homocedasticidad, data.frame(
        Variable = col_bio_actual,
        F_value = NA,
        p_value = NA
      ))
    }
  }

  # ------------ IDENTIFICACIÓN Y EXCLUSIÓN DE OUTLIERS EN DATOS ----------------
  # Transformación a formato largo para cálculo
  columnas_seleccionadas_plot <- c(columna_sujeto_id, tgs_variable_nombre, nombres_bio_tomas)
  datos_plot_largo <- datos %>%
    select(all_of(columnas_seleccionadas_plot)) %>%
    pivot_longer(
      cols = all_of(nombres_bio_tomas),
      names_to = "Toma_Nombre",
      values_to = "Valor_Bioquimico"
    ) %>%
    mutate(Toma = as.integer(gsub(paste0("^", bioquimica_base_nombre, "(\\d)º$"), "\\1", Toma_Nombre))) %>%
    filter(!is.na(Toma))

  if(nrow(datos_plot_largo) == 0){
      stop("No se pudieron generar datos en formato largo para la detección de outliers.")
  }

  tabla_outliers <- datos_plot_largo %>%
    group_by(Toma) %>%
    mutate(
      Q1 = quantile(Valor_Bioquimico, 0.25, na.rm = TRUE),
      Q3 = quantile(Valor_Bioquimico, 0.75, na.rm = TRUE),
      IQR_val = Q3 - Q1,
      Limite_Inferior = Q1 - 1.5 * IQR_val,
      Limite_Superior = Q3 + 1.5 * IQR_val,
      Es_Outlier = Valor_Bioquimico < Limite_Inferior | Valor_Bioquimico > Limite_Superior,
      Tipo_Outlier = case_when(
        Valor_Bioquimico < Limite_Inferior ~ "Bajo",
        Valor_Bioquimico > Limite_Superior ~ "Alto",
        TRUE ~ "Normal"
      )
    ) %>%
    filter(Es_Outlier) %>%
    select(all_of(columna_sujeto_id), Toma, Toma_Nombre, Valor_Bioquimico, Tipo_Outlier, Limite_Inferior, Limite_Superior) %>%
    arrange(Toma, .data[[columna_sujeto_id]])

  # ------------------ CREACIÓN DE DATAFRAME SIN OUTLIERS -----------------
  # Identificar sujetos que NO son outlier en NINGUNA toma
  sujetos_outliers <- unique(tabla_outliers[[columna_sujeto_id]])
  datos_sin_outliers <- datos[!(datos[[columna_sujeto_id]] %in% sujetos_outliers), ]
  # Comprobación básica de dimensión
  if(nrow(datos_sin_outliers) < 2){
    stop("El dataframe sin outliers tiene menos de dos sujetos, imposible continuar el análisis.")
  }

  # ------------------ CÁLCULO DE CORRELACIONES INDIVIDUALES TGS-BIOQUÍMICA (Sin outliers) -----------------
  resultados_individuales_lista <- list()
  for (i in 1:6) {
    col_bio_actual <- nombres_bio_tomas[i]
    test_resultado <- tryCatch({
      cor.test(datos_sin_outliers[[tgs_variable_nombre]], datos_sin_outliers[[col_bio_actual]],
               method = "pearson", use = "pairwise.complete.obs")
    }, error = function(e) {
      warning(paste("No se pudo calcular la correlación entre", tgs_variable_nombre, "y", col_bio_actual, ":", e$message))
      return(list(estimate = NA, p.value = NA))
    })
    resultados_individuales_lista[[i]] <- data.frame(
      Variable_TGS = tgs_variable_nombre,
      Variable_Bioquimica_Toma = col_bio_actual,
      Toma = i,
      Coeficiente_Correlacion = ifelse(is.null(test_resultado$estimate), NA, test_resultado$estimate[[1]]),
      P_Valor = ifelse(is.null(test_resultado$p.value), NA, test_resultado$p.value)
    )
  }
  tabla_correlaciones_individuales <- do.call(rbind, resultados_individuales_lista)

  # ------------------ MATRIZ Y VISUALIZACIÓN DE CORRELACIÓN (Sin outliers) -----------------
  columnas_para_matriz <- c(tgs_variable_nombre, nombres_bio_tomas)
  datos_subset_matriz <- datos_sin_outliers[, columnas_para_matriz, drop = FALSE]
  datos_subset_matriz_completos <- datos_subset_matriz[rowSums(is.na(datos_subset_matriz)) < ncol(datos_subset_matriz), ]
  matriz_cor <- NA
  plot_matriz_cor <- NULL
  if(nrow(datos_subset_matriz_completos) >= 2 && ncol(datos_subset_matriz_completos) > 0 && all(sapply(datos_subset_matriz_completos, is.numeric))) {
      matriz_cor <- cor(datos_subset_matriz_completos, use = "pairwise.complete.obs")
      if(requireNamespace("ggcorrplot", quietly = TRUE)) {
          plot_matriz_cor <- ggcorrplot::ggcorrplot(matriz_cor, hc.order = TRUE, type = "lower", lab = TRUE, lab_size = 3,
                                                    colors = c("#6D9EC1", "white", "#E46726"),
                                                    title = paste("Matriz de Correlación (sin outliers):\n", tgs_variable_nombre, "&", bioquimica_base_nombre)) +
            theme(plot.title = element_text(hjust = 0.5))
      } else {
          warning("Paquete 'ggcorrplot' no instalado. La matriz de correlación no será graficada, solo devuelta como tabla.")
      }
  } else {
      warning("No hay suficientes datos numéricos completos para calcular o graficar la matriz de correlación sin outliers.")
  }

  # ------------------ TRANSFORMACIÓN Y GRÁFICO DE TRAYECTORIAS INDIVIDUALES (Sin outliers) -----------------
  datos_plot_largo_sin_outliers <- datos_sin_outliers %>%
    select(all_of(columnas_seleccionadas_plot)) %>%
    pivot_longer(
      cols = all_of(nombres_bio_tomas),
      names_to = "Toma_Nombre",
      values_to = "Valor_Bioquimico"
    ) %>%
    mutate(Toma = as.integer(gsub(paste0("^", bioquimica_base_nombre, "(\\d)º$"), "\\1", Toma_Nombre))) %>%
    filter(!is.na(Toma))

  if(nrow(datos_plot_largo_sin_outliers) == 0){
      stop("No se pudieron generar datos en formato largo para el gráfico de trayectorias sin outliers.")
  }

  grafico_trayectorias_individuales <- ggplot(datos_plot_largo_sin_outliers,
                                             aes(x = Toma,
                                                 y = Valor_Bioquimico,
                                                 group = .data[[columna_sujeto_id]],
                                                 color = .data[[tgs_variable_nombre]])) +
    geom_line(alpha = 0.7) +
    geom_point(alpha = 0.7, size = 1.5) +
    stat_summary(aes(group = 1), fun = mean, geom = "line", color = "red", size = 1.2, linetype = "dashed") +
    stat_summary(aes(group = 1), fun = mean, geom = "point", color = "red", size = 2, shape = 18) +
    scale_x_continuous(breaks = 1:6) +
    labs(
      title = paste("Trayectorias de", bioquimica_base_nombre, "por Sujeto (sin outliers)"),
      subtitle = paste("Coloreado por", tgs_variable_nombre, "\nLínea de tendencia roja: Media"),
      x = "Toma (Tiempo)",
      y = paste("Valor de", bioquimica_base_nombre),
      color = tgs_variable_nombre
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          plot.subtitle = element_text(hjust = 0.5),
          legend.position = "bottom")

  if (!is.numeric(datos_plot_largo_sin_outliers[[tgs_variable_nombre]])) {
    grafico_trayectorias_individuales <- grafico_trayectorias_individuales +
      scale_color_brewer(palette = "Set1")
  } else {
    grafico_trayectorias_individuales <- grafico_trayectorias_individuales +
      scale_color_viridis_c()
  }

  # ------------------ GENERACIÓN DE CURVAS ROC CON DATOS SIN OUTLIERS -----------------
  lista_curvas_roc <- list()
  for (i in 1:nrow(tabla_correlaciones_individuales)) {
    corr_row <- tabla_correlaciones_individuales[i, ]
    p_valor <- corr_row$P_Valor
    col_bio_actual <- corr_row$Variable_Bioquimica_Toma

    if (!is.na(p_valor) && p_valor < 0.05 &&
        !is.null(datos_sin_outliers[[tgs_variable_nombre]]) && !is.null(datos_sin_outliers[[col_bio_actual]]) &&
        sum(!is.na(datos_sin_outliers[[tgs_variable_nombre]]) & !is.na(datos_sin_outliers[[col_bio_actual]])) > 1) {

      bio_binario <- as.factor(datos_sin_outliers[[col_bio_actual]] > median(datos_sin_outliers[[col_bio_actual]], na.rm = TRUE))

      if (nlevels(bio_binario) < 2) {
        warning(paste("No se puede generar curva ROC para", col_bio_actual,
                      "porque la variable bioquímica binaria solo tiene un nivel. Ajuste el umbral de TGS%."))
        next
      }

      roc_data <- data.frame(
        response = bio_binario,
        predictor = datos_sin_outliers[[tgs_variable_nombre]]
      )
      roc_data <- na.omit(roc_data)

      if (nrow(roc_data) > 1 && nlevels(roc_data$response) == 2) {
        tryCatch({
          roc_obj <- roc(response = roc_data$response,
                         predictor = roc_data$predictor,
                         levels = rev(levels(roc_data$response)))
          auc_roc <- auc(roc_obj)
          ci_roc <- ci.auc(roc_obj)

          pval <- tryCatch({
            roc.test(roc_obj)$p.value
          }, error = function(e) NA)

          ci_text <- paste0(" (AUC: ", round(auc_roc, 2), 
                            " [95% CI:", paste(round(ci_roc[c(1,3)],2), collapse="-"),
                            "], p=", signif(pval, 2), ")")

          plot_roc <- ggroc(roc_obj) +
            geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = "darkgrey", linetype = "dashed") +
            labs(title = paste("Curva ROC para", tgs_variable_nombre, "prediciendo", col_bio_actual,
                               "\n", ci_text),
                 x = "False Positive Rate",
                 y = "True Positive Rate") +
            theme_minimal() +
            theme(plot.title = element_text(hjust = 0.5, face = "bold"))

          print(plot_roc)

          lista_curvas_roc[[col_bio_actual]] <- plot_roc

        }, error = function(e) {
          warning(paste("Error al generar la curva ROC para", col_bio_actual, ":", e$message))
        })
      } else {
          warning(paste("No hay suficientes datos para generar curva ROC para", col_bio_actual,
                        "o la variable binaria no tiene dos niveles después de NA o umbral."))
      }
    }
  }

  # ------------------ RETORNO DE RESULTADOS DEL ANÁLISIS -----------------
  return(list(
    tabla_correlaciones_individuales = tabla_correlaciones_individuales,
    matriz_correlacion_completa = matriz_cor,
    plot_matriz_correlacion = plot_matriz_cor,
    grafico_trayectorias_individuales = grafico_trayectorias_individuales,
    tabla_outliers = tabla_outliers,
    curvas_roc_significativas = lista_curvas_roc,
    normalidad_por_toma = tabla_normalidad,
    homocedasticidad_por_toma = tabla_homocedasticidad,
    datos_sin_outliers = datos_sin_outliers
  ))
}

```

Ejecución de la función para TGS muscular
```{r}
# Define la variable TGS (Total Glycogen Stores) que se usará de forma constante en todos los análisis.
tgs_fija <- "%TGS muscular"

# Crea un vector de caracteres con los nombres base de las variables bioquímicas a analizar.
# La función 'analizar_bio_tgs_sin_outliers' construirá los nombres completos (ej., "FERRIT1º", "FERRIT2º") a partir de estos.
variables_bioquimicas_a_iterar <- c("FERRIT", "FE", "CPK", "LDH", "CREATIN", "HB", "HMTCO", "UREA", "BUN")

# Iniciar un bucle que aplica la función sobre cada variable bioquímica base
todos_los_analisis_sin_outliers <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {

  # Mensaje de inicio en consola para cada variable bioquímica
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))
  
  resultado_para_esta_bio <- tryCatch({
    analizar_bio_tgs_sin_outliers(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio))
  })

  return(resultado_para_esta_bio)
})

# Asigna nombres a la lista de resultados
names(todos_los_analisis_sin_outliers) <- variables_bioquimicas_a_iterar

```

FERRIT
```{r}
# Ejemplo para FE:
todos_los_analisis_sin_outliers$FERRIT
```

FE
```{r}
# Ejemplo para FE:
todos_los_analisis_sin_outliers$FE
```

CPK
```{r}
# Ejemplo para CPK:
todos_los_analisis_sin_outliers$CPK
```

LDH
```{r}
# Ejemplo para LDH:
todos_los_analisis_sin_outliers$LDH
```

CREATIN
```{r}
# Ejemplo para CREATIN:
todos_los_analisis_sin_outliers$CREATIN
```
UREA
```{r}
# Ejemplo para UREA:
todos_los_analisis_sin_outliers$UREA
```

BUN
```{r}
# Ejemplo para BUN:
todos_los_analisis_sin_outliers$BUN
```

HB
```{r}
# Ejemplo para HB:
todos_los_analisis_sin_outliers$HB
```

HMTCO
```{r}
# Ejemplo para HMTCO:
todos_los_analisis_sin_outliers$HMTCO
```
EJECUTAR FUNCIÓN CORRELACIÓN TGS HEPÁTICO Y VARIABELS
```{r}
# Define la variable TGS (Total Glycogen Stores) que se utilizará de forma constante en todos los análisis.
tgs_fija <- "%TGS hepático"

# Crea un vector de caracteres con los nombres base de las variables bioquímicas a analizar.
# La función 'analizar_bio_tgs_jugador' construirá los nombres completos (ej., "GOT1º", "GOT2º") a partir de estos.
variables_bioquimicas_a_iterar <- c("GOT", "GPT", "GGT", "UREA", "BUN", "LDH", "CREATIN", "ACURICO")

# Inicia un bucle que aplica una función a cada elemento de 'variables_bioquimicas_a_iterar'.
# 'lapply' devolverá una lista donde cada elemento será el resultado de la función aplicada a una variable bioquímica.
# Esta lista, 'todos_los_analisis2', almacenará todos los resultados de los análisis.
todos_los_analisis_sin_outliers <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {

  # Imprime un mensaje en la consola para indicar el inicio del análisis para la variable bioquímica actual.
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))

  # Usa 'tryCatch' para manejar posibles errores durante la ejecución de 'analizar_bio_tgs_jugador'.
  # Si ocurre un error con una variable, se registrará el error y el bucle continuará con la siguiente.
  resultado_para_esta_bio <- tryCatch({
    # Llama a la función 'analizar_bio_tgs_jugador' con los parámetros definidos.
    # 'datos' es el dataframe completo, "SUJETO" es la columna de ID, 'tgs_fija' es la variable TGS constante,
    # y 'nombre_base_bio' es la variable bioquímica actual del bucle.
    analizar_bio_tgs_sin_outliers(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si 'analizar_bio_tgs_jugador' arroja un error, este bloque lo captura.
    # Se imprime un mensaje de error detallado en la consola.
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    # Devuelve una lista indicando que hubo un error, incluyendo el mensaje de error y la variable que lo causó.
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio))
  })

  # Retorna el resultado del análisis (o el mensaje de error si lo hubo) para la variable bioquímica actual.
  # Este resultado se añadirá como un elemento a la lista 'todos_los_analisis2'.
  return(resultado_para_esta_bio)
})

# Asigna los nombres de las variables bioquímicas a cada elemento de la lista 'todos_los_analisis2'.
# Esto permite acceder a los resultados de un análisis específico usando el nombre de la variable (ej., 'todos_los_analisis2$GOT').
names(todos_los_analisis_sin_outliers) <- variables_bioquimicas_a_iterar
```

Resultados GOT
```{r}
todos_los_analisis_sin_outliers$GOT #Permite acceder a los resultados del análisis específico para la variable bioquímica "GOT"
```

Resultados GPT
```{r}
todos_los_analisis_sin_outliers$GPT #Permite acceder a los resultados del análisis específico para la variable bioquímica "GPT"
```

Resultados GGT
```{r}
todos_los_analisis_sin_outliers$GGT #Permite acceder a los resultados del análisis específico para la variable bioquímica "GGT"
```

Resultados UREA
```{r}
todos_los_analisis_sin_outliers$UREA #Permite acceder a los resultados del análisis específico para la variable bioquímica "UREA"
```

Resultados BUN
```{r}
todos_los_analisis_sin_outliers$BUN #Permite acceder a los resultados del análisis específico para la variable bioquímica "BUN"
```

LDH
```{r}
# Ejemplo para LDH:
todos_los_analisis_sin_outliers$LDH
```


CREATIN
```{r}
# Ejemplo para CREATIN:
todos_los_analisis_sin_outliers$CREATIN
```


ACURICO
```{r}
# Ejemplo para ACURICO:
todos_los_analisis_sin_outliers$ACURICO
```


EJECUTAR FUNCIÓN CORRELACIÓN TGS CARDIO Y VARIABELS
```{r}
# Define la variable TGS (Total Glycogen Stores) que se utilizará de forma constante en este análisis.
tgs_fija <- "%TGS cardio"

# Crea un vector de caracteres con los nombres base de las variables bioquímicas a analizar.
# En este caso, solo se incluye "CPK". La función 'analizar_bio_tgs_jugador' construirá los nombres completos (ej., "CPK1º", "CPK2º") a partir de este.
variables_bioquimicas_a_iterar <- c("CPK", "LDH", "FERRIT", "FE", "HB", "HMTCO", "GLUCOSA", "NA", "K", "CL", "HDL", "LDL", "VCM", "HCM", "CHCM", "RDW")

# Inicia un bucle que aplica una función a cada elemento de 'variables_bioquimicas_a_iterar'.
# 'lapply' devolverá una lista donde cada elemento será el resultado de la función aplicada a una variable bioquímica.
# Esta lista, 'todos_los_analisis2', almacenará los resultados de los análisis.
todos_los_analisis_sin_outliers <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {

  # Imprime un mensaje en la consola para indicar el inicio del análisis para la variable bioquímica actual.
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))

  # Usa 'tryCatch' para manejar posibles errores durante la ejecución de 'analizar_bio_tgs_jugador'.
  # Si ocurre un error con una variable, se registrará el error y el bucle continuará con la siguiente (aunque aquí solo hay una).
  resultado_para_esta_bio <- tryCatch({
    # Llama a la función 'analizar_bio_tgs_jugador' con los parámetros definidos.
    # 'datos' es el dataframe completo, "SUJETO" es la columna de ID, 'tgs_fija' es la variable TGS constante,
    # y 'nombre_base_bio' es la variable bioquímica actual del bucle.
    analizar_bio_tgs_sin_outliers(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si 'analizar_bio_tgs_jugador' arroja un error, este bloque lo captura.
    # Se imprime un mensaje de error detallado en la consola.
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    # Devuelve una lista indicando que hubo un error, incluyendo el mensaje de error y la variable que lo causó.
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio))
  })

  # Retorna el resultado del análisis (o el mensaje de error si lo hubo) para la variable bioquímica actual.
  # Este resultado se añadirá como un elemento a la lista 'todos_los_analisis2'.
  return(resultado_para_esta_bio)
})

# Asigna los nombres de las variables bioquímicas a cada elemento de la lista 'todos_los_analisis2'.
# Esto permite acceder a los resultados del análisis específico usando el nombre de la variable (ej., 'todos_los_analisis2$CPK').
names(todos_los_analisis_sin_outliers) <- variables_bioquimicas_a_iterar
```

CPK
```{r}
todos_los_analisis_sin_outliers$CPK #Permite acceder a los resultados del análisis específico para la variable bioquímica "CPK"
```

LDH
```{r}
todos_los_analisis_sin_outliers$LDH
```

```{r}
todos_los_analisis_sin_outliers$FERRIT
```

```{r}
todos_los_analisis_sin_outliers$FE
```

```{r}
todos_los_analisis_sin_outliers$HB
```

```{r}
todos_los_analisis_sin_outliers$HMTCO
```

```{r}
todos_los_analisis_sin_outliers$GLUCOSA
```

```{r}
todos_los_analisis_sin_outliers$NA
```

```{r}
todos_los_analisis_sin_outliers$K
```

```{r}
todos_los_analisis_sin_outliers$CL
```

```{r}
todos_los_analisis_sin_outliers$HDL
```

```{r}
todos_los_analisis_sin_outliers$LDL
```

```{r}
todos_los_analisis_sin_outliers$VCM
```

```{r}
todos_los_analisis_sin_outliers$HCM
```

```{r}
todos_los_analisis_sin_outliers$CHCM
```

```{r}
todos_los_analisis_sin_outliers$RDW
```

EJECUTAR FUNCIÓN CORRELACIÓN TGS EFICACIA Y VARIABELS
```{r}
# Define la variable TGS (Total Glycogen Stores) que se utilizará de forma constante en este conjunto de análisis.
tgs_fija <- "%TGS eficacia"

# Crea un vector de caracteres con los nombres base de las variables bioquímicas a analizar.
# La función 'analizar_bio_tgs_jugador' construirá los nombres completos de las columnas (ej., "GOT1º", "GOT2º") a partir de estos nombres base.
variables_bioquimicas_a_iterar <- c("GOT", "GPT", "GGT", "CPK", "FE", "FERRIT", "HMTCO", "HB", "HEMAT", "CPK", "LDH", "GLUCOSA", "HCM", "VCM")

# Inicia un bucle que aplica una función a cada elemento del vector 'variables_bioquimicas_a_iterar'.
# La función 'lapply' devolverá una lista donde cada elemento será el resultado de la función aplicada a una de las variables bioquímicas.
# Esta lista, 'todos_los_analisis2', almacenará todos los resultados generados por cada análisis individual.
todos_los_analisis_sin_outliers <- lapply(variables_bioquimicas_a_iterar, function(nombre_base_bio) {

  # Imprime un mensaje en la consola para indicar claramente qué análisis está a punto de comenzar.
  # Esto es útil para el seguimiento durante la ejecución del script.
  cat(paste0("\n--- Iniciando análisis para: TGS='", tgs_fija, "' y Bioquímica Base='", nombre_base_bio, "' ---\n"))

  # Utiliza 'tryCatch' para gestionar posibles errores que puedan surgir durante la ejecución de 'analizar_bio_tgs_jugador'.
  # Si se produce un error con una variable específica, este bloque lo captura, evita que el script se detenga por completo
  # y permite que el bucle continúe con las variables restantes.
  resultado_para_esta_bio <- tryCatch({
    # Llama a la función 'analizar_bio_tgs_jugador' con los parámetros necesarios:
    # - 'datos': el dataframe completo que contiene toda la información.
    # - 'columna_sujeto_id': el nombre de la columna que identifica de forma única a cada sujeto ("SUJETO").
    # - 'tgs_variable_nombre': la variable TGS fija que se está analizando en esta serie de comparaciones.
    # - 'bioquimica_base_nombre': el nombre base de la variable bioquímica actual que se procesa en la iteración del bucle.
    analizar_bio_tgs_sin_outliers(
      datos = datos,
      columna_sujeto_id = "SUJETO",
      tgs_variable_nombre = tgs_fija,
      bioquimica_base_nombre = nombre_base_bio
    )
  }, error = function(e) {
    # Si la función 'analizar_bio_tgs_jugador' genera un error, este bloque se activa.
    # Se imprime un mensaje de advertencia detallado en la consola, indicando qué variable causó el error y el mensaje específico del error.
    cat(paste0("ERROR al procesar '", nombre_base_bio, "': ", e$message, "\n"))
    # Devuelve una lista que contiene indicadores de error (TRUE), el mensaje de error y el nombre de la variable bioquímica.
    # Esto permite identificar fácilmente qué análisis fallaron y por qué.
    return(list(error = TRUE, mensaje_error = e$message, variable_bio = nombre_base_bio))
  })

  # Retorna el resultado del análisis para la variable bioquímica actual.
  # Si el análisis fue exitoso, será la lista completa de resultados; de lo contrario, será la lista con el mensaje de error.
  # Este resultado se añade como un elemento a la lista 'todos_los_analisis2'.
  return(resultado_para_esta_bio)
})

# Asigna los nombres de las variables bioquímicas (ej., "GOT", "GPT") a cada elemento de la lista 'todos_los_analisis2'.
# Esto mejora la legibilidad y facilita el acceso a los resultados de un análisis específico utilizando el nombre de la variable
# (por ejemplo, `todos_los_analisis2$GOT` para acceder a los resultados relacionados con GOT).
names(todos_los_analisis_sin_outliers) <- variables_bioquimicas_a_iterar
```

Resultados GOT
```{r}
todos_los_analisis_sin_outliers$GOT #Permite acceder a los resultados del análisis específico para la variable bioquímica "GOT"
```

Resultados GPT
```{r}
todos_los_analisis_sin_outliers$GPT #Permite acceder a los resultados del análisis específico para la variable bioquímica "GPT"
```

Resultados GGT
```{r}
todos_los_analisis_sin_outliers$GGT #Permite acceder a los resultados del análisis específico para la variable bioquímica "GGT"
```

Resultados CPK
```{r}
todos_los_analisis_sin_outliers$CPK #Permite acceder a los resultados del análisis específico para la variable bioquímica "CPK"
```

Resultados FE
```{r}
todos_los_analisis_sin_outliers$FE #Permite acceder a los resultados del análisis específico para la variable bioquímica "FE"
```

Resultados FERRITINA
```{r}
todos_los_analisis_sin_outliers$FERRIT #Permite acceder a los resultados del análisis específico para la variable bioquímica "FERRIT"
```

Resultados HMTCO
```{r}
todos_los_analisis_sin_outliers$HMTCO #Permite acceder a los resultados del análisis específico para la variable bioquímica "HMTCO"
```

Resultados HB
```{r}
todos_los_analisis_sin_outliers$HB #Permite acceder a los resultados del análisis específico para la variable bioquímica "HB"
```

Resultados HEMAT
```{r}
todos_los_analisis_sin_outliers$HEMAT #Permite acceder a los resultados del análisis específico para la variable bioquímica "HEMAT"
```

GLUCOSA
```{r}
todos_los_analisis_sin_outliers$GLUCOSA
```
